#ΠΕΖ2015 Άσκηση 6η

Θεωρείστε ότι δίδεται ο εξής ορισμός δομής: 

> struct node {
>	int data;
>	struct node *next; 
>};

Με βάση τον ορισμό αυτό, το ζητούμενο είναι να σχεδιάσετε και να υλοποιήσετε
μια συνδεδεμένη λίστα στοιχείων που ικανοποιεί τον κανόνα πρόσβασης
First-In-First-Out, με άλλα λόγια μια δομή ουράς (queue). Στις δομές αυτές
το στοιχείο το οποίο εντέθηκε πρώτο στη λίστα (με μία πράξη Insert) είναι και
αυτό που θα διαγραφεί πρώτο (με μία πράξη Delete). Αυτή η λογική πράξεων μπορεί
να υλοποιηθεί αν η ένθεση στοιχείων γίνεται στο τέλος της λίστας, ενώ η διαγραφή
αφαιρεί στοιχεία από την αρχή της λίστας.

Γράψτε συναρτήσεις σύμφωνα με τα παρακάτω πρότυπα, καθώς και ένα πρόγραμμα
επίδειξης:

* void Insert(struct node **headRef, int newData);
* int Delete(struct node **headRef);
* int GetNth(struct node *head, int index);
* int Count(struct node *head, int searchFor);

Η συνάρτηση **Insert()** δέχεται ως όρισμα ένα δείκτη στον δείκτη που αντιστοιχεί
στην κεφαλή της λίστας. Δεσμεύει μνήμη, με κλήση της malloc(), για μια δομή του
τύπου struct node, αποθηκεύει σ’αυτήν την ακέραια τιμή newData (στο πεδίο data)
και συνδέει κατάλληλα την νέα δομή (βάσει του πεδίου next) ώστε η λίστα να
ικανοποιεί τον κανόνα πρόσβασης *"First In/First Out"*, συνεπώς ενθέτει το νέο
στοιχείο στο τέλος της λίστας.

Η συνάρτηση **Delete()** δέχεται ως όρισμα ένα δείκτη στον δείκτη που αντιστοιχεί
στην κεφαλή της λίστας διαγράφει και επιστρέφει ένα στοιχείο της λίστας έτσι
ώστε να ικανοποιείται ο κανόνας "First In First Out", συνεπώς διαγράφει και
επιστρέφει το πρώτο στοιχείο της λίστας.

Η GetNth() δέχεται ως όρισμα τον δείκτη που αντιστοιχεί στην κεφαλή της
λίστας, και την θέση (ως ακέραια τιμή που ξεκινά από το 0) ενός στοιχείου.
Εφόσον η λίστα περιέχει στοιχείο στην καθοριζόμενη θέση, η συνάρτηση επιστρέφει
την τιμή του πεδίου data για το στοιχείο αυτό, διαφορετικά εκτυπώνει κατάλληλο
μήνυμα και επιστρέφει την τιμή 0.

Η Count() δέχεται ως όρισμα τον δείκτη που αντιστοιχεί στην κεφαλή της λίστας,
και μια ακέραια τιμή. Εξετάζει ένα-προς-ένα όλα τα στοιχεία της λίστας και
επιστρέφει σε πόσα από αυτά το πεδίο data ισούται με την αναζητούμενη τιμή 
και επιστρέφει 0 εάν η τιμή δεν εμφανίζεται στην λίστα.

Γράψτε την main() η οποία εμφανίζει μενού επιλογών στο χρήστη:

1. Insert 
2. Delete
2. Get-Nth
3. Count
4. Έξοδος

Ανάλογα με την επιλογή του χρήστη ζητούνται τα απαραίτητα στοιχεία (π.χ. για
την πράξη Insert ζητείται από τον χρήστη η ακέραια τιμή newdata) και καλείται η κατάλληλη συνάρτηση.


----

# Πως να το κατεβάσετε:

> git clone https://github.com/georgemarselis/c_programming_project.git && cd c_programming_project; cd c_programming_project/exercise_6 && make clean && make debug;

# Επιλογές:
* -h | --help
* -f <αρχείο> αρχείο απο όπου διαβάζονται τα στοιχεία

# Παραδείγματα:

> ./queue              : run program

> ./queue -f data.txt  : run program from file

> ./queue < data.txt   : ισοδύναμο

# Δείγματα αποτελέσματος

> [gmarselis@wintermute exercise_5 (master)]$ clear; ./queue

> [gmarselis@wintermute exercise_5 (master)]$ clear; ./queue -f data.txt

# Λειτουργία:

Η λειτουργία χωρίζεται στα εξείς μέρη:

1. Ανάλυση των επιλογών της γραμμής εντολών
2. Αν υπάρχουν επιλογές τις επεξεργαζόμαστε. Η κυρίως επιλογή είναι το αρχείο από όπου θα διαβάσουμε
3. Διαβάζουμε το αρχείο με τα στοιχεία
4. Το επεξεργαζόμαστε σε δομές
5. Τυπώνουμε τις επεξεργαζμένες δομές

